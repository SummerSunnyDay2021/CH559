C51 COMPILER V9.56.0.0   UART                                                              10/16/2020 16:16:15 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: F:\Keil\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\UART.ls
                    -t) TABS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          /*
   2           *  2020年10月16日 14点02分 ☆5
   3           * 
   4           *  使用 CH559 内置的 UART 组件（二）
   5           *
   6           *  UART0 相较 UART1 简单一些，UART0 为基本型串口，而 UART1 带有 FIFO 和其他流控 Mod
             -em 信号
   7           * 
   8           *  本项目致力于实现基本的串口配置，在接受数据加 1 并回发 (SBUF = SBUF + 1)
   9           *  
  10           *  UART0 使用如下寄存器：
  11           *  
  12           *  SCON [7:0] UART0 控制寄存器
  13           *  SM0 SM1 SM2 REN TB8 RB8 TI RI
  14           *   7   6   5   4   3   2  1  0
  15           * 
  16           *  SM0:    串口位宽配置位，0 为 8个数据位，1 为 9 个数据位
  17           *  SM1:    串口时钟输入配置位，0 为固定波特率，1 则由定时器 T1/T2 提供一个时
             -
  18           *  SM2:    接收结束定义位，在模式 0 中，SM2 必须置 0
  19           *                       在模式 1 中，SM2 置 1 表示串口接收到有效的停止位时，接受
             -效并结束，否则接受是无效
  20           *                       SM2 置 0 表示串口接收使用移位寄存器方式，不需要正确的停
             -位，SBUF 就可以读出信息。
  21           *  REN:    允许接收控制位，0 为禁止接收，1 为允许接收
  22           *  TB8:    9 位模式下，用于写入的第九位数据，可以是奇偶校验，多机通信中表
             -发送地址字节(1)还是数据字节(0)
  23           *  RB8:    9 位模式下，存放接受数据的第九位，在 模式1 中，RB8 存放停止位，在 
             -模式0 中，不使用 RB8
  24           *  TI:     发送中断标识位，一个字节发送完成之后由硬件置 1，需软件清零
  25           *  RI:     接受中断标识位，一个字节接收完成之后由硬件置 1，需软件清零
  26           * 
  27           *  SM0 -- SM1
  28           *    0     0   模式 0，移位寄存器模式，波特率 Fsys/12
  29           *    0     1   模式 1，8 位异步串口模式，波特率可变，由定时器 T1/T2 产生
  30           *    1     0   模式 2，9 位异步串口模式，波特率是 Fsys/128(SMOD==0)或是 Fsys/32(SMOD==1)
  31           *    1     1   模式 3，9 位异步串口模式，波特率可变，由定时器 T1/T2 产生
  32           * 
  33           *  中断使能寄存器 IE [7:0]
  34          
  35              EA E_DIS ET2 ES ET1 EX1 ET0 EX0
  36               7   6    5   4  3   2   1   0
  37          
  38              EA:     全局中断使能位，置 1 并且 E_DIS == 0 允许中断，置 0 屏蔽中断
  39              E_DIS:    全局中断禁用控制位，置 1 屏蔽中断，置 0 并且 EA == 1 允许中断
  40              ET2:    定时器 T2 中断使能位，置 1 允许 T2 中断，置 0 屏蔽
  41              ES:     UART0 中断使能位，置 1 允许 UART0 中断，置 0 屏蔽
  42              ET1:    定时器 T1 中断使能位，同 ET2
  43              EX1:    外部中断 INT1 使能位，置 1 允许中断，置 0 屏蔽
  44              ET0:    定时器 T0 中断使能位，同 ET2
  45              EX0:    外部中断 INT0 使能位，同 EX1
  46          
  47          
  48              ！！！由于 模式0 的失败，CH559 配套的代码中使用的是 定时器T1 产生的可调
C51 COMPILER V9.56.0.0   UART                                                              10/16/2020 16:16:15 PAGE 2   

             -钟，我也找不到关于 模式0 的参考，
  49              这个项目使用 模式1，有定时器1 来产生时钟。
  50          
  51              TCON [7:0] 控制寄存器
  52              TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0
  53               7   6   5   4   3   2   1   0
  54          
  55              TF1 ---- 定时器 T1 溢出中断标识位，进入定时器 T1 中断后自动清零
  56              TR1 ---- 定时器 T1 启动停止位，置 1 启动，由软件置位或者清零
  57              TF0 ---- 定时器 T0 溢出中断标识位，进入定时器 T0 中断后自动清零
  58              TR0 ---- 定时器 T0 启动停止位，置 1 启动，由软件置位或者清零
  59              IE1 ---- INT1 外部中断请求标识位，进入中断后自动清零
  60              IT1 ---- INT1 外部中断触发方式控制位，0 表示低电平触发，1 表示下降边沿触发
  61              IE0 ---- INT0 外部中断请求标识位，进入中断后自动清零
  62              IT0 ---- INT0 外部中断触发方式控制位，0 表示低电平触发，1 表示下降边沿触发
  63                
  64              TMOD [7:0] ---- 0x00 (复位值) 定时器方式寄存器 
  65              bT1_GATE bT1_CT bT1_M1 bT1_M0 bT0_GATE bT0_CT bT0_M1 bT0_M0
  66                 7        6      5      4      3        2      1      0
  67              *      bT1_GATE ---- 门控使能位，控制 T1 的是否由外部信号启动，置 1 、TR1 == 1 
             -且 INT1 输入高电平时启动 T1
  68              *                    置 0 则忽略 INT1 的输入。
  69              *      bT1_CT   ---- 定时/计数方式选择位，0 则处于定时方式，1 则处于脉冲计数
             -式，使用 T1 的下降沿脉冲进行计数
  70              *      bT1_M1   ---- T1 模式选择高位
  71              *      bT1_M0   ---- T1 模式选择低位
  72              *           M1 : M0
  73              *            0    0     模式 0： 13 位定时/脉冲计时模式，由 TLn 的低 5 位和 THn 的 
             -8 位构成，TLn 的高 3 位无效，
  74              *                       当计数器从 0b1111_1111_1111_1000 到 0b0000_0000_0000_0000 时，溢出
             -识位 TFn 置 1，
  75              *                       溢出后需要重载计数初值。
  76              *            0    1     模式 1： 16 位定时/脉冲计数模式，由 TLn 和 THn 共 16 位组成
             -，定时器溢出时，溢出标志位 TFn 置 1
  77              *                       溢出后需要重载计数初值
  78              *            1    0     模式 2： 8  位自动重载模式，计数单元使用 TLn,THn 作为重载
             -计数单元。自动重载计数。
  79              *            1    1     模式 3： T0 进入模式 3 会将定时器 T0 分割为两个独立的 8 
             -计数器，其中 TL0 交由 T0 控制，TH0 交由 T1 控制
  80              *                       其中 TH0 占用 T1 的全部控制位和中断资源。        
  81              *                       T1 进入模式 3 ，T1 会停止
  82              * 
  83              * 
  84           * 还有一小部分寄存器在 定时器T2 的配置寄存器当中。😔😔😔
  85           *  
  86           * T2CON [7:0]
  87           *      TF2/CAP1F    EXF2    RCLK    TCLK    EXEN2   TR2    C_T2    CP_RL2
  88           *            7       6       5       4       3       2       1       0
  89           *      
  90           *      RCLK:   UART0 RX 接收端的时钟选择，置 0 使用 Timer1，置 1 则为 Timer2 
  91           *      TCLK:   UART0 TX 发送端的时钟选择，同上
  92           * 
  93           * T2MOD [7:0]
  94           *      bTMR_CLK    bT2_CLK    bT1_CLK    bT0_CLK    bT2_CAP_M1    bT2_CAP_M0    T2OE    bT2_CAP1_EN 
  95           *          7           6          5        4              3            2          1          0
  96           *      
  97           *      bTMR_CLK:   已选择快速时钟的 T0/T1/T2 定时器的最快时钟使能，置 1 使用 Fsys
             -置 0 使用分频率时钟，本位的选择不影响选择标准时钟的定时器
  98           *      
  99           *      bT2_CLK:    T2 内部时钟选择，0 为标准时钟 Fsys/12，1 为快速时钟 
 100                  *                  定时/计数模式下：Fsys/4(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)
 101                  *                  UART0 时钟模式下：Fsys/2(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)
C51 COMPILER V9.56.0.0   UART                                                              10/16/2020 16:16:15 PAGE 3   

 102                  * 
 103                  
 104                  bT1_CLK:    !!!注意，这是 定时器 T1 定时器 T1 定时器 T1 的时钟控制位，不是 
             -定时器 T2 的 
 105                  bT0_CLK:    !!!注意，这是 定时器 T0 定时器 T0 定时器 T0 的时钟控制位，不是 
             -定时器 T2 的
 106                              0 为标准时钟，Fsys/12
 107                              1 为快速时钟，Fsys/4(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)
 108          
 109              PCON [7:0] 电源控制寄存器
 110              SMOD N/C bRST_FLAG1 bRST_FLAG0 GF1 GF0 PD N/C
 111                7   6      5          4       3   2   1  0
 112          
 113              SMOD ---- 由定时器 T1 产生 UART0 的时钟时，选择 UART0 模式1、2、3 的输入时钟的
             -率
 114                       0 为慢速模式, F = Fsys/2
 115                       1 为快速模式, F = Fsys
 116          
 117          
 118          **/
 119          
 120          
 121          #include"CH559.H"
 122          
 123          unsigned char code baud_set = 256 - 12000000/16/7200;
 124          
 125          void Uart0_Init(void){
 126   1      
 127   1          SM0     = 0;    // 8 位数据
 128   1          SM1     = 1;    // 由定时器T1/T2 产生时钟
 129   1          SM2     = 1;    // 等待结束位
 130   1          REN     = 1;    // 允许接收数据
 131   1      
 132   1          EA      = 1;    // 全局中断使能
 133   1          E_DIS   = 0;    // 关闭中断禁用
 134   1          ES      = 1;    // 启用 UART0 中断
 135   1      } 
 136          
 137          void Timer1_Init(void){
 138   1        
 139   1          // 定时器T1 模式2，8位自动重载
 140   1          TMOD = 0x20;
 141   1      
 142   1          // 使用定时器 T1 作为串口的时钟源
 143   1          RCLK = 0;
 144   1          TCLK = 0;
 145   1      
 146   1          // 使能定时器 T1 快速时钟，F = Fsys/4
 147   1          // 10100000
 148   1          T2MOD = 0xA0;
 149   1      
 150   1          // 电源频率控制
 151   1          // 10000000
 152   1          PCON = 0x80 ;
 153   1      
 154   1          // 配置定时器初值
 155   1          TL1 = baud_set;
 156   1          TH1 = baud_set;
 157   1      
 158   1          // 启动定时器 T1
 159   1          TR1 = 1;
 160   1      }
C51 COMPILER V9.56.0.0   UART                                                              10/16/2020 16:16:15 PAGE 4   

 161          
 162          unsigned char tmp = 0x00;
 163          
 164          void main(void){
 165   1          
 166   1          Uart0_Init();
 167   1          Timer1_Init();
 168   1          SBUF = 0xA1;
 169   1      
 170   1          while(1);
 171   1      
 172   1      }
 173          
 174          void Uart0_Interrupt(void) interrupt 4 {
 175   1          if(TI){
 176   2              TI = 0;
 177   2              SBUF = tmp;
 178   2              tmp++;
 179   2          }
 180   1          if(RI){
 181   2              RI = 0;
 182   2          }
 183   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     68    ----
   CONSTANT SIZE    =      1    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
