/*
 *  2020年10月16日 14点02分 ☆5
 * 
 *  使用 CH559 内置的 UART 组件
 *
 *  UART0 相较 UART1 简单一些，UART0 为基本型串口，而 UART1 带有 FIFO 和其他流控 Modem 信号
 * 
 *  本项目致力于实现基本的串口配置，连续发送数据
 *  
 *  UART0 使用如下寄存器：
 *  
 *  SCON [7:0] UART0 控制寄存器
 *  SM0 SM1 SM2 REN TB8 RB8 TI RI
 *   7   6   5   4   3   2  1  0
 * 
 *  SM0:    串口位宽配置位，0 为 8个数据位，1 为 9 个数据位
 *  SM1:    串口时钟输入配置位，0 为固定波特率，1 则由定时器 T1/T2 提供一个时钟
 *  SM2:    接收结束定义位，在模式 0 中，SM2 必须置 0
 *                       在模式 1 中，SM2 置 1 表示串口接收到有效的停止位时，接受有效并结束，否则接受是无效
 *                       SM2 置 0 表示串口接收使用移位寄存器方式，不需要正确的停止位，SBUF 就可以读出信息。
 *  REN:    允许接收控制位，0 为禁止接收，1 为允许接收
 *  TB8:    9 位模式下，用于写入的第九位数据，可以是奇偶校验，多机通信中表示发送地址字节(1)还是数据字节(0)
 *  RB8:    9 位模式下，存放接受数据的第九位，在 模式1 中，RB8 存放停止位，在 模式0 中，不使用 RB8
 *  TI:     发送中断标识位，一个字节发送完成之后由硬件置 1，需软件清零
 *  RI:     接受中断标识位，一个字节接收完成之后由硬件置 1，需软件清零
 * 
 *  SM0 -- SM1
 *    0     0   模式 0，移位寄存器模式，波特率 Fsys/12
 *    0     1   模式 1，8 位异步串口模式，波特率可变，由定时器 T1/T2 产生
 *    1     0   模式 2，9 位异步串口模式，波特率是 Fsys/128(SMOD==0)或是 Fsys/32(SMOD==1)
 *    1     1   模式 3，9 位异步串口模式，波特率可变，由定时器 T1/T2 产生
 * 
 *  中断使能寄存器 IE [7:0]

		EA E_DIS ET2 ES ET1 EX1 ET0 EX0
		 7   6    5   4  3   2   1   0

		EA:			全局中断使能位，置 1 并且 E_DIS == 0 允许中断，置 0 屏蔽中断
		E_DIS:		全局中断禁用控制位，置 1 屏蔽中断，置 0 并且 EA == 1 允许中断
		ET2:		定时器 T2 中断使能位，置 1 允许 T2 中断，置 0 屏蔽
		ES:			UART0 中断使能位，置 1 允许 UART0 中断，置 0 屏蔽
		ET1:		定时器 T1 中断使能位，同 ET2
		EX1:		外部中断 INT1 使能位，置 1 允许中断，置 0 屏蔽
		ET0:		定时器 T0 中断使能位，同 ET2
		EX0:		外部中断 INT0 使能位，同 EX1


    ！！！由于 模式0 的失败，CH559 配套的代码中使用的是 定时器T1 产生的可调时钟，我也找不到关于 模式0 的参考，
    这个项目使用 模式1，有定时器1 来产生时钟。

    TCON [7:0] 控制寄存器
    TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0
     7   6   5   4   3   2   1   0

    TF1 ---- 定时器 T1 溢出中断标识位，进入定时器 T1 中断后自动清零
    TR1 ---- 定时器 T1 启动停止位，置 1 启动，由软件置位或者清零
    TF0 ---- 定时器 T0 溢出中断标识位，进入定时器 T0 中断后自动清零
    TR0 ---- 定时器 T0 启动停止位，置 1 启动，由软件置位或者清零
    IE1 ---- INT1 外部中断请求标识位，进入中断后自动清零
    IT1 ---- INT1 外部中断触发方式控制位，0 表示低电平触发，1 表示下降边沿触发
    IE0 ---- INT0 外部中断请求标识位，进入中断后自动清零
    IT0 ---- INT0 外部中断触发方式控制位，0 表示低电平触发，1 表示下降边沿触发
			
    TMOD [7:0] ---- 0x00 (复位值) 定时器方式寄存器 
    bT1_GATE bT1_CT bT1_M1 bT1_M0 bT0_GATE bT0_CT bT0_M1 bT0_M0
       7        6      5      4      3        2      1      0
    *      bT1_GATE ---- 门控使能位，控制 T1 的是否由外部信号启动，置 1 、TR1 == 1 并且 INT1 输入高电平时启动 T1
    *                    置 0 则忽略 INT1 的输入。
    *      bT1_CT   ---- 定时/计数方式选择位，0 则处于定时方式，1 则处于脉冲计数方式，使用 T1 的下降沿脉冲进行计数
    *      bT1_M1   ---- T1 模式选择高位
    *      bT1_M0   ---- T1 模式选择低位
    *           M1 : M0
    *            0    0     模式 0： 13 位定时/脉冲计时模式，由 TLn 的低 5 位和 THn 的 8 位构成，TLn 的高 3 位无效，
    *                       当计数器从 0b1111_1111_1111_1000 到 0b0000_0000_0000_0000 时，溢出标识位 TFn 置 1，
    *                       溢出后需要重载计数初值。
    *            0    1     模式 1： 16 位定时/脉冲计数模式，由 TLn 和 THn 共 16 位组成，定时器溢出时，溢出标志位 TFn 置 1
    *                       溢出后需要重载计数初值
    *            1    0     模式 2： 8  位自动重载模式，计数单元使用 TLn,THn 作为重载计数单元。自动重载计数。
    *            1    1     模式 3： T0 进入模式 3 会将定时器 T0 分割为两个独立的 8 位计数器，其中 TL0 交由 T0 控制，TH0 交由 T1 控制
    *                       其中 TH0 占用 T1 的全部控制位和中断资源。        
    *                       T1 进入模式 3 ，T1 会停止
    * 
    * 
 * 还有一小部分寄存器在 定时器T2 的配置寄存器当中。😔😔😔
 *  
 * T2CON [7:0]
 *      TF2/CAP1F    EXF2    RCLK    TCLK    EXEN2   TR2    C_T2    CP_RL2
 *            7       6       5       4       3       2       1       0
 *      
 *      RCLK:   UART0 RX 接收端的时钟选择，置 0 使用 Timer1，置 1 则为 Timer2 
 *      TCLK:   UART0 TX 发送端的时钟选择，同上
 * 
 * T2MOD [7:0]
 *      bTMR_CLK    bT2_CLK    bT1_CLK    bT0_CLK    bT2_CAP_M1    bT2_CAP_M0    T2OE    bT2_CAP1_EN 
 *          7           6          5        4              3            2          1          0
 *      
 *      bTMR_CLK:   已选择快速时钟的 T0/T1/T2 定时器的最快时钟使能，置 1 使用 Fsys，置 0 使用分频率时钟，本位的选择不影响选择标准时钟的定时器
 *      
 *      bT2_CLK:    T2 内部时钟选择，0 为标准时钟 Fsys/12，1 为快速时钟 
        *                  定时/计数模式下：Fsys/4(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)
        *                  UART0 时钟模式下：Fsys/2(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)
        * 
        
        bT1_CLK:    !!!注意，这是 定时器 T1 定时器 T1 定时器 T1 的时钟控制位，不是 定时器 T2 的 
        bT0_CLK:    !!!注意，这是 定时器 T0 定时器 T0 定时器 T0 的时钟控制位，不是 定时器 T2 的
                    0 为标准时钟，Fsys/12
                    1 为快速时钟，Fsys/4(bTMR_CLK==0) 或 Fsys(bTMR_CLK==1)

    PCON [7:0] 电源控制寄存器
    SMOD N/C bRST_FLAG1 bRST_FLAG0 GF1 GF0 PD N/C
      7   6      5          4       3   2   1  0

    SMOD ---- 由定时器 T1 产生 UART0 的时钟时，选择 UART0 模式1、2、3 的输入时钟的频率
             0 为慢速模式, F = Fsys/2
             1 为快速模式, F = Fsys
**/

/* 2020年10月16日 16点37分 
		
	1. 实验了接受数据并自增1 后回发，一切正常 (SBUF = SBUF + 1;)
	2. 实验了连续发送数据，
			8051 的串口功能比较简陋，连续发送的时候数据前一帧停止位紧挨着下一帧的起始位
			逻辑分析仪解码完全正确，串口调试助手上出现一些错误。
			结论：不要连续的使用发送数据，连续发送至少等待一个中断周期
 */


#include"CH559.H"

// 这是一个计算公式，但其中的除以 16 是什么原因我还没弄明白 🤷‍
// 256 = 0xFF 是 8位计数器的最大计数值
// 12000000 = 12M 是晶振频率
// 7200 是我设置的 波特率(bps)
// 为什么要除以➗16呢？？？
unsigned char code baud_set = 256 - 12000000/16/7200;

void Uart0_Init(void){

    SM0     = 0;    // 8 位数据
    SM1     = 1;    // 由定时器T1/T2 产生时钟
    SM2     = 1;    // 等待结束位
    REN     = 1;    // 允许接收数据

    EA      = 1;    // 全局中断使能
    E_DIS   = 0;    // 关闭中断禁用
    ES      = 1;    // 启用 UART0 中断
} 

void Timer1_Init(void){
	
    // 定时器T1 模式2，8位自动重载
		TMOD = 0x20;

    // 使用定时器 T1 作为串口的时钟源
    RCLK = 0;
    TCLK = 0;

    // 使能定时器 T1 快速时钟，F = Fsys/4
		// 10100000
		T2MOD = 0xA0;

    // 电源频率控制
		// 10000000
    PCON = 0x80 ;

    // 配置定时器初值
    TL1 = baud_set;
    TH1 = baud_set;

    // 启动定时器 T1
    TR1 = 1;
}

unsigned char tmp = 0x00;

void main(void){
		
    Uart0_Init();
    Timer1_Init();
	
		// 发送第一个串口信号
		SBUF = 0xA1;

    while(1);

}

void Uart0_Interrupt(void) interrupt 4 {
    if(TI){
        TI = 0;
		// 连续发送，每次自增 1
		// 中断函数里的变量必须是全局变量，
		// 如果把 tmp 定义在 main() 函数里，编译器会报错
				SBUF = tmp;
				tmp++;
    }
    if(RI){
        RI = 0;

		//  接受到数据后将数据加1 并回发
		//	SBUF = SBUF + 1;
    }
}

